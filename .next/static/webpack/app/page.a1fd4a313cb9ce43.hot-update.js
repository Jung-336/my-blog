"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/posts.ts":
/*!**************************!*\
  !*** ./src/lib/posts.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBulkTestPosts: () => (/* binding */ createBulkTestPosts),\n/* harmony export */   createPost: () => (/* binding */ createPost),\n/* harmony export */   createTestPosts: () => (/* binding */ createTestPosts),\n/* harmony export */   deletePost: () => (/* binding */ deletePost),\n/* harmony export */   getHashtags: () => (/* binding */ getHashtags),\n/* harmony export */   getPost: () => (/* binding */ getPost),\n/* harmony export */   getPostWithHashtags: () => (/* binding */ getPostWithHashtags),\n/* harmony export */   getPosts: () => (/* binding */ getPosts),\n/* harmony export */   togglePublish: () => (/* binding */ togglePublish),\n/* harmony export */   updatePost: () => (/* binding */ updatePost)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\nconst categories = [\n    'AI',\n    'Technology',\n    'Machine Learning',\n    'Data Science',\n    'Programming',\n    'Web Development',\n    'Cloud Computing',\n    'Cybersecurity',\n    'Blockchain',\n    'IoT'\n];\nconst generateTestPosts = (authorId)=>{\n    const posts = [];\n    const baseDate = new Date();\n    for(let i = 0; i < 100; i++){\n        const date = new Date(baseDate);\n        date.setDate(date.getDate() - i); // Each post is one day older than the previous\n        const category = categories[Math.floor(Math.random() * categories.length)];\n        const title = \"\".concat(category, \" Trends in \").concat(2024 - Math.floor(Math.random() * 5), \": A Comprehensive Guide\");\n        const slug = \"\".concat(category.toLowerCase(), \"-trends-\").concat(2024 - Math.floor(Math.random() * 5), \"-\").concat(i + 1);\n        posts.push({\n            title,\n            excerpt: \"Exploring the latest developments and future prospects in \".concat(category.toLowerCase(), \". This comprehensive guide covers everything you need to know about the current state and future of \").concat(category.toLowerCase(), \".\"),\n            content: \"\\n        <h2>Introduction</h2>\\n        <p>The field of \".concat(category.toLowerCase(), \" is evolving at an unprecedented pace. In this article, we'll explore the latest trends and developments that are shaping the future of this exciting domain.</p>\\n        \\n        <h2>Current State</h2>\\n        <p>As we move through 2024, \").concat(category.toLowerCase(), \" continues to transform industries and create new opportunities. Let's examine the key factors driving this transformation.</p>\\n        \\n        <h2>Key Trends</h2>\\n        <ul>\\n          <li>Trend 1: Innovation in \").concat(category.toLowerCase(), \"</li>\\n          <li>Trend 2: Emerging technologies</li>\\n          <li>Trend 3: Industry applications</li>\\n          <li>Trend 4: Future predictions</li>\\n        </ul>\\n        \\n        <h2>Conclusion</h2>\\n        <p>The future of \").concat(category.toLowerCase(), \" looks promising, with numerous opportunities for growth and innovation. Stay tuned for more updates on this exciting field.</p>\\n      \"),\n            category,\n            slug,\n            published: true,\n            author_id: authorId,\n            created_at: date.toISOString(),\n            updated_at: date.toISOString()\n        });\n    }\n    return posts;\n};\nasync function createBulkTestPosts() {\n    // First, get the current user's ID\n    const { data: { user }, error: userError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n    if (userError || !user) {\n        throw new Error('No authenticated user found');\n    }\n    const testPosts = generateTestPosts(user.id);\n    // Insert posts in batches of 10 to avoid hitting limits\n    const batchSize = 10;\n    const results = [];\n    for(let i = 0; i < testPosts.length; i += batchSize){\n        const batch = testPosts.slice(i, i + batchSize);\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').insert(batch).select();\n        if (error) {\n            console.error('Error creating test posts batch:', error);\n            throw error;\n        }\n        results.push(...data || []);\n        console.log(\"Created batch \".concat(i / batchSize + 1, \" of \").concat(Math.ceil(testPosts.length / batchSize)));\n    }\n    console.log('Created all test posts:', results.length);\n    return results;\n}\nasync function createTestPosts() {\n    // First, get the current user's ID\n    const { data: { user }, error: userError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n    if (userError || !user) {\n        throw new Error('No authenticated user found');\n    }\n    const testPosts = [\n        {\n            title: 'The Future of AI: A New Era of Innovation',\n            excerpt: 'Exploring the latest developments in artificial intelligence and their impact on our future.',\n            content: '<p>This is a test post about AI and its future implications.</p>',\n            category: 'AI',\n            slug: 'future-of-ai',\n            published: true,\n            author_id: user.id\n        },\n        {\n            title: 'Building Multi-Agent Systems',\n            excerpt: 'A deep dive into creating intelligent systems that work together to solve complex problems.',\n            content: '<p>This is a test post about multi-agent systems.</p>',\n            category: 'Technology',\n            slug: 'multi-agent-systems',\n            published: true,\n            author_id: user.id\n        },\n        {\n            title: 'The Rise of LLMs',\n            excerpt: 'Understanding how Large Language Models are transforming the way we interact with technology.',\n            content: '<p>This is a test post about Large Language Models.</p>',\n            category: 'AI',\n            slug: 'rise-of-llms',\n            published: true,\n            author_id: user.id\n        }\n    ];\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').insert(testPosts).select();\n    if (error) {\n        console.error('Error creating test posts:', error);\n        throw error;\n    }\n    console.log('Created test posts:', data);\n    return data;\n}\nasync function createPost(post) {\n    let hashtagIds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    const { data: postData, error: postError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').insert([\n        post\n    ]).select().single();\n    if (postError) {\n        throw postError;\n    }\n    if (hashtagIds.length > 0) {\n        const { error: hashtagError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts_hashtags').insert(hashtagIds.map((hashtagId)=>({\n                post_id: postData.id,\n                hashtag_id: hashtagId\n            })));\n        if (hashtagError) {\n            throw hashtagError;\n        }\n    }\n    return postData;\n}\nasync function updatePost(id, post) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').update(post).eq('id', id).select().single();\n    if (error) {\n        throw error;\n    }\n    return data;\n}\nasync function deletePost(id) {\n    const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').delete().eq('id', id);\n    if (error) {\n        throw error;\n    }\n}\nasync function getPost(slug) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').select('*').eq('slug', slug).eq('published', true).single();\n    if (error) {\n        throw error;\n    }\n    return data;\n}\nasync function getPosts() {\n    let published = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n    console.log('Fetching posts with published status:', published);\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').select('*').eq('published', published).order('created_at', {\n        ascending: false\n    });\n    if (error) {\n        console.error('Error fetching posts:', error);\n        throw error;\n    }\n    console.log('Fetched posts:', data);\n    return data;\n}\nasync function togglePublish(id, published) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').update({\n        published\n    }).eq('id', id).select().single();\n    if (error) {\n        throw error;\n    }\n    return data;\n}\nasync function getHashtags() {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('hashtags').select('*').order('name');\n    if (error) {\n        throw error;\n    }\n    return data;\n}\nasync function getPostWithHashtags(slug) {\n    const { data: post, error: postError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts').select('*').eq('slug', slug).eq('published', true).single();\n    if (postError) {\n        throw postError;\n    }\n    const { data: hashtags, error: hashtagError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('posts_hashtags').select('hashtag_id, hashtags(*)').eq('post_id', post.id);\n    if (hashtagError) {\n        throw hashtagError;\n    }\n    return {\n        ...post,\n        hashtags: hashtags.map((h)=>h.hashtags)\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVztRQUNiLE1BQU1BO0lBQ1I7SUFFQSxNQUFNLEVBQUV4QixNQUFNMkMsUUFBUSxFQUFFekMsT0FBT3dCLFlBQVksRUFBRSxHQUFHLE1BQU10RCwrQ0FBUUEsQ0FDM0R5QyxJQUFJLENBQUMsa0JBQ0xFLE1BQU0sQ0FBQywyQkFDUGtCLEVBQUUsQ0FBQyxXQUFXWixLQUFLYixFQUFFO0lBRXhCLElBQUlrQixjQUFjO1FBQ2hCLE1BQU1BO0lBQ1I7SUFFQSxPQUFPO1FBQ0wsR0FBR0wsSUFBSTtRQUNQc0IsVUFBVUEsU0FBU2hCLEdBQUcsQ0FBQ2lCLENBQUFBLElBQUtBLEVBQUVELFFBQVE7SUFDeEM7QUFDRiIsInNvdXJjZXMiOlsiRDpcXHZpYmUtY29kaW5nXFxteS1ibG9nXFxzcmNcXGxpYlxccG9zdHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICcuL3N1cGFiYXNlJztcblxuZXhwb3J0IGludGVyZmFjZSBQb3N0IHtcbiAgaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgZXhjZXJwdDogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIHNsdWc6IHN0cmluZztcbiAgcHVibGlzaGVkOiBib29sZWFuO1xuICBhdXRob3JfaWQ6IHN0cmluZztcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG4gIGhhc2h0YWdzPzogSGFzaHRhZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc2h0YWcge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbn1cblxuY29uc3QgY2F0ZWdvcmllcyA9IFsnQUknLCAnVGVjaG5vbG9neScsICdNYWNoaW5lIExlYXJuaW5nJywgJ0RhdGEgU2NpZW5jZScsICdQcm9ncmFtbWluZycsICdXZWIgRGV2ZWxvcG1lbnQnLCAnQ2xvdWQgQ29tcHV0aW5nJywgJ0N5YmVyc2VjdXJpdHknLCAnQmxvY2tjaGFpbicsICdJb1QnXTtcblxuY29uc3QgZ2VuZXJhdGVUZXN0UG9zdHMgPSAoYXV0aG9ySWQ6IHN0cmluZykgPT4ge1xuICBjb25zdCBwb3N0cyA9IFtdO1xuICBjb25zdCBiYXNlRGF0ZSA9IG5ldyBEYXRlKCk7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGJhc2VEYXRlKTtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBpKTsgLy8gRWFjaCBwb3N0IGlzIG9uZSBkYXkgb2xkZXIgdGhhbiB0aGUgcHJldmlvdXNcbiAgICBcbiAgICBjb25zdCBjYXRlZ29yeSA9IGNhdGVnb3JpZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2F0ZWdvcmllcy5sZW5ndGgpXTtcbiAgICBjb25zdCB0aXRsZSA9IGAke2NhdGVnb3J5fSBUcmVuZHMgaW4gJHsyMDI0IC0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNSl9OiBBIENvbXByZWhlbnNpdmUgR3VpZGVgO1xuICAgIGNvbnN0IHNsdWcgPSBgJHtjYXRlZ29yeS50b0xvd2VyQ2FzZSgpfS10cmVuZHMtJHsyMDI0IC0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNSl9LSR7aSArIDF9YDtcbiAgICBcbiAgICBwb3N0cy5wdXNoKHtcbiAgICAgIHRpdGxlLFxuICAgICAgZXhjZXJwdDogYEV4cGxvcmluZyB0aGUgbGF0ZXN0IGRldmVsb3BtZW50cyBhbmQgZnV0dXJlIHByb3NwZWN0cyBpbiAke2NhdGVnb3J5LnRvTG93ZXJDYXNlKCl9LiBUaGlzIGNvbXByZWhlbnNpdmUgZ3VpZGUgY292ZXJzIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8ga25vdyBhYm91dCB0aGUgY3VycmVudCBzdGF0ZSBhbmQgZnV0dXJlIG9mICR7Y2F0ZWdvcnkudG9Mb3dlckNhc2UoKX0uYCxcbiAgICAgIGNvbnRlbnQ6IGBcbiAgICAgICAgPGgyPkludHJvZHVjdGlvbjwvaDI+XG4gICAgICAgIDxwPlRoZSBmaWVsZCBvZiAke2NhdGVnb3J5LnRvTG93ZXJDYXNlKCl9IGlzIGV2b2x2aW5nIGF0IGFuIHVucHJlY2VkZW50ZWQgcGFjZS4gSW4gdGhpcyBhcnRpY2xlLCB3ZSdsbCBleHBsb3JlIHRoZSBsYXRlc3QgdHJlbmRzIGFuZCBkZXZlbG9wbWVudHMgdGhhdCBhcmUgc2hhcGluZyB0aGUgZnV0dXJlIG9mIHRoaXMgZXhjaXRpbmcgZG9tYWluLjwvcD5cbiAgICAgICAgXG4gICAgICAgIDxoMj5DdXJyZW50IFN0YXRlPC9oMj5cbiAgICAgICAgPHA+QXMgd2UgbW92ZSB0aHJvdWdoIDIwMjQsICR7Y2F0ZWdvcnkudG9Mb3dlckNhc2UoKX0gY29udGludWVzIHRvIHRyYW5zZm9ybSBpbmR1c3RyaWVzIGFuZCBjcmVhdGUgbmV3IG9wcG9ydHVuaXRpZXMuIExldCdzIGV4YW1pbmUgdGhlIGtleSBmYWN0b3JzIGRyaXZpbmcgdGhpcyB0cmFuc2Zvcm1hdGlvbi48L3A+XG4gICAgICAgIFxuICAgICAgICA8aDI+S2V5IFRyZW5kczwvaDI+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICA8bGk+VHJlbmQgMTogSW5ub3ZhdGlvbiBpbiAke2NhdGVnb3J5LnRvTG93ZXJDYXNlKCl9PC9saT5cbiAgICAgICAgICA8bGk+VHJlbmQgMjogRW1lcmdpbmcgdGVjaG5vbG9naWVzPC9saT5cbiAgICAgICAgICA8bGk+VHJlbmQgMzogSW5kdXN0cnkgYXBwbGljYXRpb25zPC9saT5cbiAgICAgICAgICA8bGk+VHJlbmQgNDogRnV0dXJlIHByZWRpY3Rpb25zPC9saT5cbiAgICAgICAgPC91bD5cbiAgICAgICAgXG4gICAgICAgIDxoMj5Db25jbHVzaW9uPC9oMj5cbiAgICAgICAgPHA+VGhlIGZ1dHVyZSBvZiAke2NhdGVnb3J5LnRvTG93ZXJDYXNlKCl9IGxvb2tzIHByb21pc2luZywgd2l0aCBudW1lcm91cyBvcHBvcnR1bml0aWVzIGZvciBncm93dGggYW5kIGlubm92YXRpb24uIFN0YXkgdHVuZWQgZm9yIG1vcmUgdXBkYXRlcyBvbiB0aGlzIGV4Y2l0aW5nIGZpZWxkLjwvcD5cbiAgICAgIGAsXG4gICAgICBjYXRlZ29yeSxcbiAgICAgIHNsdWcsXG4gICAgICBwdWJsaXNoZWQ6IHRydWUsXG4gICAgICBhdXRob3JfaWQ6IGF1dGhvcklkLFxuICAgICAgY3JlYXRlZF9hdDogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZF9hdDogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gcG9zdHM7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQnVsa1Rlc3RQb3N0cygpIHtcbiAgLy8gRmlyc3QsIGdldCB0aGUgY3VycmVudCB1c2VyJ3MgSURcbiAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gIFxuICBpZiAodXNlckVycm9yIHx8ICF1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRoZW50aWNhdGVkIHVzZXIgZm91bmQnKTtcbiAgfVxuXG4gIGNvbnN0IHRlc3RQb3N0cyA9IGdlbmVyYXRlVGVzdFBvc3RzKHVzZXIuaWQpO1xuXG4gIC8vIEluc2VydCBwb3N0cyBpbiBiYXRjaGVzIG9mIDEwIHRvIGF2b2lkIGhpdHRpbmcgbGltaXRzXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IDEwO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RQb3N0cy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgY29uc3QgYmF0Y2ggPSB0ZXN0UG9zdHMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSk7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwb3N0cycpXG4gICAgICAuaW5zZXJ0KGJhdGNoKVxuICAgICAgLnNlbGVjdCgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB0ZXN0IHBvc3RzIGJhdGNoOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJlc3VsdHMucHVzaCguLi4oZGF0YSB8fCBbXSkpO1xuICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGJhdGNoICR7aSAvIGJhdGNoU2l6ZSArIDF9IG9mICR7TWF0aC5jZWlsKHRlc3RQb3N0cy5sZW5ndGggLyBiYXRjaFNpemUpfWApO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ0NyZWF0ZWQgYWxsIHRlc3QgcG9zdHM6JywgcmVzdWx0cy5sZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRlc3RQb3N0cygpIHtcbiAgLy8gRmlyc3QsIGdldCB0aGUgY3VycmVudCB1c2VyJ3MgSURcbiAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gIFxuICBpZiAodXNlckVycm9yIHx8ICF1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRoZW50aWNhdGVkIHVzZXIgZm91bmQnKTtcbiAgfVxuXG4gIGNvbnN0IHRlc3RQb3N0cyA9IFtcbiAgICB7XG4gICAgICB0aXRsZTogJ1RoZSBGdXR1cmUgb2YgQUk6IEEgTmV3IEVyYSBvZiBJbm5vdmF0aW9uJyxcbiAgICAgIGV4Y2VycHQ6ICdFeHBsb3JpbmcgdGhlIGxhdGVzdCBkZXZlbG9wbWVudHMgaW4gYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2UgYW5kIHRoZWlyIGltcGFjdCBvbiBvdXIgZnV0dXJlLicsXG4gICAgICBjb250ZW50OiAnPHA+VGhpcyBpcyBhIHRlc3QgcG9zdCBhYm91dCBBSSBhbmQgaXRzIGZ1dHVyZSBpbXBsaWNhdGlvbnMuPC9wPicsXG4gICAgICBjYXRlZ29yeTogJ0FJJyxcbiAgICAgIHNsdWc6ICdmdXR1cmUtb2YtYWknLFxuICAgICAgcHVibGlzaGVkOiB0cnVlLFxuICAgICAgYXV0aG9yX2lkOiB1c2VyLmlkLFxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICdCdWlsZGluZyBNdWx0aS1BZ2VudCBTeXN0ZW1zJyxcbiAgICAgIGV4Y2VycHQ6ICdBIGRlZXAgZGl2ZSBpbnRvIGNyZWF0aW5nIGludGVsbGlnZW50IHN5c3RlbXMgdGhhdCB3b3JrIHRvZ2V0aGVyIHRvIHNvbHZlIGNvbXBsZXggcHJvYmxlbXMuJyxcbiAgICAgIGNvbnRlbnQ6ICc8cD5UaGlzIGlzIGEgdGVzdCBwb3N0IGFib3V0IG11bHRpLWFnZW50IHN5c3RlbXMuPC9wPicsXG4gICAgICBjYXRlZ29yeTogJ1RlY2hub2xvZ3knLFxuICAgICAgc2x1ZzogJ211bHRpLWFnZW50LXN5c3RlbXMnLFxuICAgICAgcHVibGlzaGVkOiB0cnVlLFxuICAgICAgYXV0aG9yX2lkOiB1c2VyLmlkLFxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICdUaGUgUmlzZSBvZiBMTE1zJyxcbiAgICAgIGV4Y2VycHQ6ICdVbmRlcnN0YW5kaW5nIGhvdyBMYXJnZSBMYW5ndWFnZSBNb2RlbHMgYXJlIHRyYW5zZm9ybWluZyB0aGUgd2F5IHdlIGludGVyYWN0IHdpdGggdGVjaG5vbG9neS4nLFxuICAgICAgY29udGVudDogJzxwPlRoaXMgaXMgYSB0ZXN0IHBvc3QgYWJvdXQgTGFyZ2UgTGFuZ3VhZ2UgTW9kZWxzLjwvcD4nLFxuICAgICAgY2F0ZWdvcnk6ICdBSScsXG4gICAgICBzbHVnOiAncmlzZS1vZi1sbG1zJyxcbiAgICAgIHB1Ymxpc2hlZDogdHJ1ZSxcbiAgICAgIGF1dGhvcl9pZDogdXNlci5pZCxcbiAgICB9LFxuICBdO1xuXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Bvc3RzJylcbiAgICAuaW5zZXJ0KHRlc3RQb3N0cylcbiAgICAuc2VsZWN0KCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGVzdCBwb3N0czonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBjb25zb2xlLmxvZygnQ3JlYXRlZCB0ZXN0IHBvc3RzOicsIGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBvc3QocG9zdDogT21pdDxQb3N0LCAnaWQnIHwgJ2NyZWF0ZWRfYXQnIHwgJ3VwZGF0ZWRfYXQnPiwgaGFzaHRhZ0lkczogc3RyaW5nW10gPSBbXSkge1xuICBjb25zdCB7IGRhdGE6IHBvc3REYXRhLCBlcnJvcjogcG9zdEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwb3N0cycpXG4gICAgLmluc2VydChbcG9zdF0pXG4gICAgLnNlbGVjdCgpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChwb3N0RXJyb3IpIHtcbiAgICB0aHJvdyBwb3N0RXJyb3I7XG4gIH1cblxuICBpZiAoaGFzaHRhZ0lkcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgeyBlcnJvcjogaGFzaHRhZ0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Bvc3RzX2hhc2h0YWdzJylcbiAgICAgIC5pbnNlcnQoXG4gICAgICAgIGhhc2h0YWdJZHMubWFwKGhhc2h0YWdJZCA9PiAoe1xuICAgICAgICAgIHBvc3RfaWQ6IHBvc3REYXRhLmlkLFxuICAgICAgICAgIGhhc2h0YWdfaWQ6IGhhc2h0YWdJZFxuICAgICAgICB9KSlcbiAgICAgICk7XG5cbiAgICBpZiAoaGFzaHRhZ0Vycm9yKSB7XG4gICAgICB0aHJvdyBoYXNodGFnRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvc3REYXRhO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUG9zdChpZDogc3RyaW5nLCBwb3N0OiBQYXJ0aWFsPFBvc3Q+KSB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Bvc3RzJylcbiAgICAudXBkYXRlKHBvc3QpXG4gICAgLmVxKCdpZCcsIGlkKVxuICAgIC5zZWxlY3QoKVxuICAgIC5zaW5nbGUoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlUG9zdChpZDogc3RyaW5nKSB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Bvc3RzJylcbiAgICAuZGVsZXRlKClcbiAgICAuZXEoJ2lkJywgaWQpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQb3N0KHNsdWc6IHN0cmluZykge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwb3N0cycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdzbHVnJywgc2x1ZylcbiAgICAuZXEoJ3B1Ymxpc2hlZCcsIHRydWUpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQb3N0cyhwdWJsaXNoZWQ6IGJvb2xlYW4gPSB0cnVlKSB7XG4gIGNvbnNvbGUubG9nKCdGZXRjaGluZyBwb3N0cyB3aXRoIHB1Ymxpc2hlZCBzdGF0dXM6JywgcHVibGlzaGVkKTtcbiAgXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Bvc3RzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3B1Ymxpc2hlZCcsIHB1Ymxpc2hlZClcbiAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9zdHM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ0ZldGNoZWQgcG9zdHM6JywgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlUHVibGlzaChpZDogc3RyaW5nLCBwdWJsaXNoZWQ6IGJvb2xlYW4pIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncG9zdHMnKVxuICAgIC51cGRhdGUoeyBwdWJsaXNoZWQgfSlcbiAgICAuZXEoJ2lkJywgaWQpXG4gICAgLnNlbGVjdCgpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRIYXNodGFncygpOiBQcm9taXNlPEhhc2h0YWdbXT4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdoYXNodGFncycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLm9yZGVyKCduYW1lJyk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBvc3RXaXRoSGFzaHRhZ3Moc2x1Zzogc3RyaW5nKSB7XG4gIGNvbnN0IHsgZGF0YTogcG9zdCwgZXJyb3I6IHBvc3RFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncG9zdHMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnc2x1ZycsIHNsdWcpXG4gICAgLmVxKCdwdWJsaXNoZWQnLCB0cnVlKVxuICAgIC5zaW5nbGUoKTtcblxuICBpZiAocG9zdEVycm9yKSB7XG4gICAgdGhyb3cgcG9zdEVycm9yO1xuICB9XG5cbiAgY29uc3QgeyBkYXRhOiBoYXNodGFncywgZXJyb3I6IGhhc2h0YWdFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncG9zdHNfaGFzaHRhZ3MnKVxuICAgIC5zZWxlY3QoJ2hhc2h0YWdfaWQsIGhhc2h0YWdzKCopJylcbiAgICAuZXEoJ3Bvc3RfaWQnLCBwb3N0LmlkKTtcblxuICBpZiAoaGFzaHRhZ0Vycm9yKSB7XG4gICAgdGhyb3cgaGFzaHRhZ0Vycm9yO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5wb3N0LFxuICAgIGhhc2h0YWdzOiBoYXNodGFncy5tYXAoaCA9PiBoLmhhc2h0YWdzKVxuICB9O1xufSAiXSwibmFtZXMiOlsic3VwYWJhc2UiLCJjYXRlZ29yaWVzIiwiZ2VuZXJhdGVUZXN0UG9zdHMiLCJhdXRob3JJZCIsInBvc3RzIiwiYmFzZURhdGUiLCJEYXRlIiwiaSIsImRhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImNhdGVnb3J5IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwidGl0bGUiLCJzbHVnIiwidG9Mb3dlckNhc2UiLCJwdXNoIiwiZXhjZXJwdCIsImNvbnRlbnQiLCJwdWJsaXNoZWQiLCJhdXRob3JfaWQiLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiY3JlYXRlQnVsa1Rlc3RQb3N0cyIsImRhdGEiLCJ1c2VyIiwiZXJyb3IiLCJ1c2VyRXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsIkVycm9yIiwidGVzdFBvc3RzIiwiaWQiLCJiYXRjaFNpemUiLCJyZXN1bHRzIiwiYmF0Y2giLCJzbGljZSIsImZyb20iLCJpbnNlcnQiLCJzZWxlY3QiLCJjb25zb2xlIiwibG9nIiwiY2VpbCIsImNyZWF0ZVRlc3RQb3N0cyIsImNyZWF0ZVBvc3QiLCJwb3N0IiwiaGFzaHRhZ0lkcyIsInBvc3REYXRhIiwicG9zdEVycm9yIiwic2luZ2xlIiwiaGFzaHRhZ0Vycm9yIiwibWFwIiwiaGFzaHRhZ0lkIiwicG9zdF9pZCIsImhhc2h0YWdfaWQiLCJ1cGRhdGVQb3N0IiwidXBkYXRlIiwiZXEiLCJkZWxldGVQb3N0IiwiZGVsZXRlIiwiZ2V0UG9zdCIsImdldFBvc3RzIiwib3JkZXIiLCJhc2NlbmRpbmciLCJ0b2dnbGVQdWJsaXNoIiwiZ2V0SGFzaHRhZ3MiLCJnZXRQb3N0V2l0aEhhc2h0YWdzIiwiaGFzaHRhZ3MiLCJoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/posts.ts\n"));

/***/ })

});